---
phase: 07-migration-consolidation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Makefile
  - backend/scripts/db_backup.py
autonomous: true

must_haves:
  truths:
    - "User can create timestamped database backup with single command"
    - "Backup file is compressed and stored in ./backups/"
    - "User can restore database from backup file"
  artifacts:
    - path: "backend/scripts/db_backup.py"
      provides: "Database backup and restore functionality"
      min_lines: 80
    - path: "Makefile"
      provides: "db-backup and db-restore targets"
      contains: "db-backup:"
  key_links:
    - from: "Makefile"
      to: "backend/scripts/db_backup.py"
      via: "uv run python scripts/db_backup.py"
      pattern: "uv run python scripts/db_backup\\.py"
---

<objective>
Create local development database backup infrastructure for migration consolidation safety.

Purpose: Enable safe rollback if migration consolidation introduces issues. The existing docker/backup.sh only works with Docker containers - we need a local development equivalent.

Output: New `make db-backup` and `make db-restore` Makefile targets that work with local PostgreSQL.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-migration-consolidation/07-CONTEXT.md
@.planning/phases/07-migration-consolidation/07-RESEARCH.md
@docker/backup.sh
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database backup script</name>
  <files>backend/scripts/db_backup.py</files>
  <action>
Create a Python script for database backup and restore operations:

1. Parse DATABASE_URL from environment or .env file to extract connection details
2. Implement `backup` command:
   - Create timestamped backup file: `./backups/hnf1b_backup_YYYYMMDD_HHMMSS.sql.gz`
   - Use `pg_dump` with flags: `-O` (no owner), `-x` (no privileges) for portability
   - Compress with gzip
   - Print backup file path and size
3. Implement `restore` command:
   - Accept backup file path as argument
   - Decompress and pipe to `psql`
   - Warn user about data loss before proceeding (use --force to skip)
4. Implement `list` command:
   - Show all backups in ./backups/ with size and date
5. Use subprocess for pg_dump/psql calls
6. Create ./backups/ directory if it doesn't exist
7. Add argparse CLI with subcommands: backup, restore, list

Use the existing docker/backup.sh as reference for the backup file naming convention.

Note: This script works with LOCAL PostgreSQL (hybrid mode), NOT Docker containers. The existing docker/backup.sh handles Docker backups.
  </action>
  <verify>
```bash
cd backend && uv run python scripts/db_backup.py --help
# Should show: backup, restore, list subcommands
```
  </verify>
  <done>Script exists with backup, restore, and list subcommands documented in --help output</done>
</task>

<task type="auto">
  <name>Task 2: Add Makefile targets for backup operations</name>
  <files>Makefile</files>
  <action>
Add new database backup targets to the root Makefile:

1. Add to .PHONY line: `db-backup db-restore db-backup-list`
2. Add targets in the DATABASE section (after db-create-admin):

```makefile
db-backup:  ## Create database backup (local PostgreSQL)
	cd backend && uv run python scripts/db_backup.py backup

db-restore:  ## Restore database from backup (usage: make db-restore FILE=path/to/backup.sql.gz)
	@if [ -z "$(FILE)" ]; then echo "Usage: make db-restore FILE=backups/hnf1b_backup_xxx.sql.gz"; exit 1; fi
	cd backend && uv run python scripts/db_backup.py restore $(FILE)

db-backup-list:  ## List available database backups
	cd backend && uv run python scripts/db_backup.py list
```

3. Update the help section to include backup commands:
```
@echo "  make db-backup         - Create database backup"
@echo "  make db-restore FILE=x - Restore from backup"
```
  </action>
  <verify>
```bash
make help | grep -E "(db-backup|db-restore)"
# Should show both backup and restore commands
```
  </verify>
  <done>Makefile has db-backup, db-restore, and db-backup-list targets with help text</done>
</task>

<task type="auto">
  <name>Task 3: Test backup and restore cycle</name>
  <files></files>
  <action>
Verify the backup infrastructure works end-to-end:

1. Ensure database is running: `make hybrid-up` (if not already)
2. Create a backup: `make db-backup`
3. Verify backup file exists and is non-empty
4. List backups: `make db-backup-list`
5. Verify backup file appears in list with correct size

Do NOT test restore on the main database (it would destroy data). The restore functionality will be used by the verification plan if needed.
  </action>
  <verify>
```bash
ls -la ./backups/hnf1b_backup_*.sql.gz 2>/dev/null | head -1
# Should show at least one backup file with non-zero size
```
  </verify>
  <done>At least one backup file exists in ./backups/ with non-zero size</done>
</task>

</tasks>

<verification>
1. `make db-backup` creates timestamped .sql.gz file in ./backups/
2. `make db-backup-list` shows backup files with dates and sizes
3. `make db-restore FILE=...` command syntax documented in help
4. Backup file is compressed (gzip format)
5. Script handles missing DATABASE_URL gracefully
</verification>

<success_criteria>
- [ ] backend/scripts/db_backup.py exists with backup/restore/list commands
- [ ] `make db-backup` creates backup successfully
- [ ] `make db-backup-list` shows available backups
- [ ] `make help` shows backup/restore commands
- [ ] At least one backup file exists in ./backups/
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration-consolidation/07-01-SUMMARY.md`
</output>
